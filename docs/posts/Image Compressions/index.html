<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Anweshan Adhikari">
<meta name="description" content="Compression to exact file sizes using machine learning.">

<title>Anweshan’s Blog - Image Compression</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;display=swap" rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Anweshan’s Blog</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">About me</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"><i class="bi bi-twitter" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#why-exact-size-compression-is-difficult" id="toc-why-exact-size-compression-is-difficult" class="nav-link active" data-scroll-target="#why-exact-size-compression-is-difficult">Why “exact size” compression is difficult</a></li>
  <li><a href="#the-common-approach-binary-search" id="toc-the-common-approach-binary-search" class="nav-link" data-scroll-target="#the-common-approach-binary-search">The common approach: Binary search</a></li>
  <li><a href="#a-smarter-approach-machine-learning-prediction" id="toc-a-smarter-approach-machine-learning-prediction" class="nav-link" data-scroll-target="#a-smarter-approach-machine-learning-prediction">A smarter approach: Machine learning prediction</a>
  <ul class="collapse">
  <li><a href="#what-is-a-prediction-model" id="toc-what-is-a-prediction-model" class="nav-link" data-scroll-target="#what-is-a-prediction-model">What is a prediction model?</a></li>
  <li><a href="#why-might-this-be-better-than-binary-search" id="toc-why-might-this-be-better-than-binary-search" class="nav-link" data-scroll-target="#why-might-this-be-better-than-binary-search">Why might this be better than binary search?</a></li>
  </ul></li>
  <li><a href="#experiments-and-results" id="toc-experiments-and-results" class="nav-link" data-scroll-target="#experiments-and-results">Experiments and results</a>
  <ul class="collapse">
  <li><a href="#iteration-efficiency" id="toc-iteration-efficiency" class="nav-link" data-scroll-target="#iteration-efficiency">Iteration Efficiency</a></li>
  <li><a href="#time-performance" id="toc-time-performance" class="nav-link" data-scroll-target="#time-performance">Time Performance</a></li>
  <li><a href="#accuracy-comparison" id="toc-accuracy-comparison" class="nav-link" data-scroll-target="#accuracy-comparison">Accuracy Comparison</a></li>
  </ul></li>
  <li><a href="#why-machine-learning-falls-short" id="toc-why-machine-learning-falls-short" class="nav-link" data-scroll-target="#why-machine-learning-falls-short">Why Machine Learning Falls Short</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Image Compression</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li></ul></div></div>
</div>

<div>
  <div class="description">
    Compression to exact file sizes using machine learning.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Anweshan Adhikari </p>
          </div>
  </div>
    
    
  </div>
  

</header>

<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># packages</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="im">from</span> scipy <span class="im">import</span> ndimage</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> GradientBoostingRegressor</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="im">from</span> unittest.mock <span class="im">import</span> patch</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="im">import</span> io</span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="im">import</span> glob</span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="im">import</span> os</span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="im">import</span> time</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>I always get annoyed when a website rejects my image because it’s 3.2MB instead of the required “under 2MB”. Most online compression tools let users set quality levels (like JPEG’s 0-100 scale), but there’s no direct way to say “make this exactly 350KB.” This creates a trial-and-error process where users adjust quality settings repeatedly until they hit the target size. In this blog post, I’ll explore why exact-size compression is challenging and investigate two approaches: a traditional binary search method and an experimental machine learning technique that attempts to predict optimal compression parameters. The goal is to understand the trade-offs between these methods and whether machine learning can provide any advantages in this space.</p>
<section id="why-exact-size-compression-is-difficult" class="level2">
<h2 class="anchored" data-anchor-id="why-exact-size-compression-is-difficult">Why “exact size” compression is difficult</h2>
<p>To understand the challenge, we need to look at how compression actually works. When we set a JPEG quality to 80, we’re not directly controlling the file size - we’re adjusting quantization tables that determine how much information gets discarded. The relationship between quality settings and resulting file size is complex and depends on several factors:</p>
<p>Content-dependent compression efficiency: A simple logo compressed at quality 80 might be 20KB, while a detailed photograph at the same setting could be 200KB.</p>
<p>Quantization steps are discrete: Most compression algorithms use block-based processing (8x8 in JPEG), with each block encoded into variable-length bit streams. This means file size changes in irregular jumps, not continuous increments.</p>
<p>Metadata overhead: EXIF data and other metadata can add 10-40KB to file size with no visual impact. Complex optimization space: The mapping between quality settings and file size is non-linear and varies by image content.</p>
<p>Let’s formulate this mathematically. For an image II I, compressed with parameter qq q (quality), the resulting size SS S is:</p>
<p><span class="math inline">\(S(I,q) = f(I,q) + M(I)\)</span></p>
<p>Where f is a non-linear function dependent on image content, and M(I) is metadata overhead. Our goal is to solve for q when S is our target size:</p>
<p><span class="math inline">\(Q = f^{-1}(S - M(I), I)\)</span></p>
<p>The problem is that <span class="math inline">\(F^-1\)</span> doesn’t have a closed-form solution, and worse, it’s different for every image.</p>
</section>
<section id="the-common-approach-binary-search" class="level2">
<h2 class="anchored" data-anchor-id="the-common-approach-binary-search">The common approach: Binary search</h2>
<p>The standard industry solution is a simple binary search through quality values. Let’s implement this:</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">def</span> encode_jpeg(image, quality):</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="co">"""Encode PIL Image as JPEG with specified quality"""</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="co"># Convert RGBA to RGB if needed</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="cf">if</span> image.mode <span class="op">==</span> <span class="st">'RGBA'</span>:</span>
<span id="cb2-5"><a href="#cb2-5"></a>        background <span class="op">=</span> Image.new(<span class="st">'RGB'</span>, image.size, (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>))</span>
<span id="cb2-6"><a href="#cb2-6"></a>        background.paste(image, mask<span class="op">=</span>image.split()[<span class="dv">3</span>])</span>
<span id="cb2-7"><a href="#cb2-7"></a>        image <span class="op">=</span> background</span>
<span id="cb2-8"><a href="#cb2-8"></a>        </span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="bu">buffer</span> <span class="op">=</span> io.BytesIO()</span>
<span id="cb2-10"><a href="#cb2-10"></a>    image.save(<span class="bu">buffer</span>, <span class="bu">format</span><span class="op">=</span><span class="st">"JPEG"</span>, quality<span class="op">=</span>quality)</span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="cf">return</span> <span class="bu">buffer</span>.getvalue()</span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="kw">def</span> compress_to_target_size(image, target_bytes, q_min<span class="op">=</span><span class="dv">5</span>, q_max<span class="op">=</span><span class="dv">95</span>, tolerance<span class="op">=</span><span class="dv">1024</span>):</span>
<span id="cb2-14"><a href="#cb2-14"></a>    <span class="co">"""Compress image to target size within tolerance"""</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>    best_result <span class="op">=</span> <span class="va">None</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>    best_size <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb2-17"><a href="#cb2-17"></a>    iterations <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>    </span>
<span id="cb2-19"><a href="#cb2-19"></a>    <span class="cf">while</span> q_min <span class="op">&lt;=</span> q_max:</span>
<span id="cb2-20"><a href="#cb2-20"></a>        iterations <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>        q <span class="op">=</span> (q_min <span class="op">+</span> q_max) <span class="op">//</span> <span class="dv">2</span>  <span class="co"># Binary search approach</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>        compressed <span class="op">=</span> encode_jpeg(image, quality<span class="op">=</span>q)</span>
<span id="cb2-23"><a href="#cb2-23"></a>        size <span class="op">=</span> <span class="bu">len</span>(compressed)</span>
<span id="cb2-24"><a href="#cb2-24"></a>        </span>
<span id="cb2-25"><a href="#cb2-25"></a>        <span class="bu">print</span>(<span class="ss">f"Iteration: Quality </span><span class="sc">{</span>q<span class="sc">}</span><span class="ss"> -&gt; Size </span><span class="sc">{</span>size<span class="op">/</span><span class="dv">1024</span><span class="sc">:.1f}</span><span class="ss">KB"</span>)</span>
<span id="cb2-26"><a href="#cb2-26"></a>        </span>
<span id="cb2-27"><a href="#cb2-27"></a>        <span class="co"># Always keep track of closest result that's under target</span></span>
<span id="cb2-28"><a href="#cb2-28"></a>        <span class="cf">if</span> size <span class="op">&lt;=</span> target_bytes <span class="kw">and</span> (target_bytes <span class="op">-</span> size <span class="op">&lt;</span> target_bytes <span class="op">-</span> best_size <span class="kw">or</span> best_size <span class="op">&gt;</span> target_bytes):</span>
<span id="cb2-29"><a href="#cb2-29"></a>            best_result <span class="op">=</span> compressed</span>
<span id="cb2-30"><a href="#cb2-30"></a>            best_size <span class="op">=</span> size</span>
<span id="cb2-31"><a href="#cb2-31"></a>        </span>
<span id="cb2-32"><a href="#cb2-32"></a>        <span class="cf">if</span> size <span class="op">&gt;</span> target_bytes:  <span class="co"># Too big, reduce quality</span></span>
<span id="cb2-33"><a href="#cb2-33"></a>            q_max <span class="op">=</span> q <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-34"><a href="#cb2-34"></a>        <span class="cf">else</span>:  <span class="co"># Fits or too small, try higher quality</span></span>
<span id="cb2-35"><a href="#cb2-35"></a>            q_min <span class="op">=</span> q <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb2-36"><a href="#cb2-36"></a>            </span>
<span id="cb2-37"><a href="#cb2-37"></a>    <span class="cf">if</span> best_result <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb2-38"><a href="#cb2-38"></a>        <span class="bu">print</span>(<span class="ss">f"Warning: Could not compress below target (</span><span class="sc">{</span>target_bytes<span class="op">/</span><span class="dv">1024</span><span class="sc">:.1f}</span><span class="ss">KB). Best result: </span><span class="sc">{</span>best_size<span class="op">/</span><span class="dv">1024</span><span class="sc">:.1f}</span><span class="ss">KB"</span>)</span>
<span id="cb2-39"><a href="#cb2-39"></a>        <span class="co"># Return the smallest possible result anyway</span></span>
<span id="cb2-40"><a href="#cb2-40"></a>        <span class="cf">return</span> encode_jpeg(image, quality<span class="op">=</span>q_min)</span>
<span id="cb2-41"><a href="#cb2-41"></a>        </span>
<span id="cb2-42"><a href="#cb2-42"></a>    <span class="bu">print</span>(<span class="ss">f"Success! Compressed to </span><span class="sc">{</span>best_size<span class="op">/</span><span class="dv">1024</span><span class="sc">:.1f}</span><span class="ss">KB in </span><span class="sc">{</span>iterations<span class="sc">}</span><span class="ss"> iterations"</span>)</span>
<span id="cb2-43"><a href="#cb2-43"></a>    <span class="cf">return</span> best_result</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>While this approach works, it has limitations:</p>
<ol type="1">
<li>Requires multiple compression attempts (log₂(quality_range) ≈ 6-7)</li>
<li>May fail to converge if tolerance is too tight</li>
<li>No learning - repeats the same process for every image</li>
</ol>
<p>Let’s test this on a sample image:</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>image <span class="op">=</span> Image.<span class="bu">open</span>(<span class="st">"sample.jpg"</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a>target_size <span class="op">=</span> <span class="dv">150</span> <span class="op">*</span> <span class="dv">1024</span>  <span class="co"># 150KB</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>result <span class="op">=</span> compress_to_target_size(image, target_size)</span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="cf">if</span> result:</span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="bu">print</span>(<span class="ss">f"Success! Final size: </span><span class="sc">{</span><span class="bu">len</span>(result)<span class="op">/</span><span class="dv">1024</span><span class="sc">:.1f}</span><span class="ss">KB"</span>)</span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="cf">with</span> <span class="bu">open</span>(<span class="st">"output.jpg"</span>, <span class="st">"wb"</span>) <span class="im">as</span> f:</span>
<span id="cb3-9"><a href="#cb3-9"></a>        f.write(result)</span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="cf">else</span>:</span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="bu">print</span>(<span class="st">"Failed to meet target size within tolerance"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Iteration: Quality 50 -&gt; Size 72.0KB
Iteration: Quality 73 -&gt; Size 104.5KB
Iteration: Quality 84 -&gt; Size 148.1KB
Iteration: Quality 90 -&gt; Size 200.3KB
Iteration: Quality 87 -&gt; Size 167.9KB
Iteration: Quality 85 -&gt; Size 152.5KB
Success! Compressed to 148.1KB in 6 iterations
Success! Final size: 148.1KB</code></pre>
</div>
</div>
<p>While we successfully found a file under our 150KB limit (at 148.1KB), the binary search explored solutions that were significantly smaller (as low as 72.0KB at quality 50). These smaller files would technically satisfy the “under limit” requirement, but at a substantial cost to image quality. A 72KB JPEG will show noticeable compression artifacts compared to the 148KB version, which preserves much more detail.</p>
<p>Our current implementation prioritizes getting as close to the limit as possible while staying under it, which is typically the ideal strategy - use the maximum allowed quality within the size constraint. However, this approach has limitations:</p>
<p>The binary search can be inefficient, often making dramatic quality jumps between iterations There’s no guarantee of visual quality preservation beyond what the quality parameter roughly indicates The relationship between quality settings and file size is highly non-linear and image-dependent</p>
<p>A more sophisticated approach would incorporate a quality floor parameter to avoid unnecessarily degrading images when the target size is generous relative to the image content. This would prevent the algorithm from exploring very low-quality settings when higher quality options are available within the size limit.</p>
</section>
<section id="a-smarter-approach-machine-learning-prediction" class="level2">
<h2 class="anchored" data-anchor-id="a-smarter-approach-machine-learning-prediction">A smarter approach: Machine learning prediction</h2>
<p>I was curious whether machine learning could improve this process by predicting the optimal quality setting directly. Let me explain the concept:</p>
<section id="what-is-a-prediction-model" class="level3">
<h3 class="anchored" data-anchor-id="what-is-a-prediction-model">What is a prediction model?</h3>
<p>A prediction model in this context is an algorithm that learns the relationship between: 1. <strong>Input features</strong>: Characteristics of the image (like edge density, entropy, etc.) and a desired target size 2. <strong>Output</strong>: The optimal JPEG quality setting that would produce that target size</p>
<p>Essentially, we’re trying to approximate the inverse of the compression function. Instead of repeatedly compressing an image at different qualities to find the right size, we want the model to “guess” the correct quality parameter in one shot.</p>
<p>The process involves:</p>
<ol type="1">
<li><strong>Training</strong>: We collect examples of images compressed at various quality settings, extracting features and recording the resulting file sizes</li>
<li><strong>Learning</strong>: The model identifies patterns between image features, quality settings, and file sizes</li>
<li><strong>Prediction</strong>: When given a new image and target size, the model estimates the quality setting that would produce that size</li>
</ol>
<p>For this experiment, I’ve chosen to use a Gradient Boosting Regressor, which is well-suited for this type of non-linear regression problem. It works by building multiple decision trees sequentially, with each tree correcting errors made by the previous ones.</p>
</section>
<section id="why-might-this-be-better-than-binary-search" class="level3">
<h3 class="anchored" data-anchor-id="why-might-this-be-better-than-binary-search">Why might this be better than binary search?</h3>
<p>If successful, this approach could: - Reduce the number of compression attempts needed (potentially just one if the prediction is accurate) - Provide more consistent results across different types of images - Better handle the non-linear relationship between quality and file size</p>
<p>Let’s extract features from images that correlate with compression efficiency:</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">def</span> extract_features(image):</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="co">"""Extract compression-relevant features from an image"""</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="co"># Convert to numpy array if needed</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(image, Image.Image):</span>
<span id="cb5-5"><a href="#cb5-5"></a>        img_array <span class="op">=</span> np.array(image)</span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="cf">else</span>:</span>
<span id="cb5-7"><a href="#cb5-7"></a>        img_array <span class="op">=</span> image</span>
<span id="cb5-8"><a href="#cb5-8"></a>    </span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="co"># Basic dimensions</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>    height, width <span class="op">=</span> img_array.shape[:<span class="dv">2</span>]</span>
<span id="cb5-11"><a href="#cb5-11"></a>    channels <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> <span class="bu">len</span>(img_array.shape) <span class="op">==</span> <span class="dv">2</span> <span class="cf">else</span> img_array.shape[<span class="dv">2</span>]</span>
<span id="cb5-12"><a href="#cb5-12"></a>    </span>
<span id="cb5-13"><a href="#cb5-13"></a>    <span class="co"># Calculate edge density using Sobel filter</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>    <span class="cf">if</span> channels <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb5-15"><a href="#cb5-15"></a>        gray <span class="op">=</span> np.mean(img_array, axis<span class="op">=</span><span class="dv">2</span>).astype(np.uint8)</span>
<span id="cb5-16"><a href="#cb5-16"></a>    <span class="cf">else</span>:</span>
<span id="cb5-17"><a href="#cb5-17"></a>        gray <span class="op">=</span> img_array</span>
<span id="cb5-18"><a href="#cb5-18"></a>    </span>
<span id="cb5-19"><a href="#cb5-19"></a>    sx <span class="op">=</span> ndimage.sobel(gray, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb5-20"><a href="#cb5-20"></a>    sy <span class="op">=</span> ndimage.sobel(gray, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-21"><a href="#cb5-21"></a>    edges <span class="op">=</span> np.hypot(sx, sy)</span>
<span id="cb5-22"><a href="#cb5-22"></a>    edge_density <span class="op">=</span> np.mean(edges) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb5-23"><a href="#cb5-23"></a>    </span>
<span id="cb5-24"><a href="#cb5-24"></a>    <span class="co"># Calculate entropy (measure of information content)</span></span>
<span id="cb5-25"><a href="#cb5-25"></a>    hist, _ <span class="op">=</span> np.histogram(gray.flatten(), bins<span class="op">=</span><span class="dv">256</span>, <span class="bu">range</span><span class="op">=</span>[<span class="dv">0</span>, <span class="dv">256</span>])</span>
<span id="cb5-26"><a href="#cb5-26"></a>    hist_norm <span class="op">=</span> hist <span class="op">/</span> (hist.<span class="bu">sum</span>() <span class="op">+</span> <span class="fl">1e-10</span>)  <span class="co"># Avoid division by zero</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>    non_zero_hist <span class="op">=</span> hist_norm[hist_norm <span class="op">&gt;</span> <span class="dv">0</span>]</span>
<span id="cb5-28"><a href="#cb5-28"></a>    entropy <span class="op">=</span> <span class="op">-</span>np.<span class="bu">sum</span>(non_zero_hist <span class="op">*</span> np.log2(non_zero_hist))</span>
<span id="cb5-29"><a href="#cb5-29"></a>    </span>
<span id="cb5-30"><a href="#cb5-30"></a>    <span class="co"># Calculate variance (measure of detail)</span></span>
<span id="cb5-31"><a href="#cb5-31"></a>    variance <span class="op">=</span> np.var(gray) <span class="op">/</span> <span class="fl">255.0</span></span>
<span id="cb5-32"><a href="#cb5-32"></a>    </span>
<span id="cb5-33"><a href="#cb5-33"></a>    <span class="co"># Measure of unique pixels (compression difficulty)</span></span>
<span id="cb5-34"><a href="#cb5-34"></a>    unique_ratio <span class="op">=</span> <span class="bu">len</span>(np.unique(gray)) <span class="op">/</span> <span class="fl">256.0</span></span>
<span id="cb5-35"><a href="#cb5-35"></a>    </span>
<span id="cb5-36"><a href="#cb5-36"></a>    <span class="cf">return</span> {</span>
<span id="cb5-37"><a href="#cb5-37"></a>        <span class="st">'width'</span>: width,</span>
<span id="cb5-38"><a href="#cb5-38"></a>        <span class="st">'height'</span>: height,</span>
<span id="cb5-39"><a href="#cb5-39"></a>        <span class="st">'aspect_ratio'</span>: width <span class="op">/</span> height,</span>
<span id="cb5-40"><a href="#cb5-40"></a>        <span class="st">'channels'</span>: channels,</span>
<span id="cb5-41"><a href="#cb5-41"></a>        <span class="st">'edge_density'</span>: edge_density,</span>
<span id="cb5-42"><a href="#cb5-42"></a>        <span class="st">'entropy'</span>: entropy,</span>
<span id="cb5-43"><a href="#cb5-43"></a>        <span class="st">'variance'</span>: variance,</span>
<span id="cb5-44"><a href="#cb5-44"></a>        <span class="st">'unique_ratio'</span>: unique_ratio,</span>
<span id="cb5-45"><a href="#cb5-45"></a>        <span class="st">'size_raw'</span>: width <span class="op">*</span> height <span class="op">*</span> channels</span>
<span id="cb5-46"><a href="#cb5-46"></a>    }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>These features capture different aspects of image complexity that affect compression:</p>
<p>Edge density (more edges → harder to compress) Entropy (higher information content → larger compressed size) Variance (more variance → more detail → larger files) Unique pixel ratio (more unique values → less compression potential)</p>
<p>Now, let’s build a prediction model:</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">def</span> train_size_predictor(image_files, quality_range<span class="op">=</span><span class="bu">range</span>(<span class="dv">5</span>, <span class="dv">96</span>, <span class="dv">10</span>)):</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="co">"""Train a model to predict compressed size from image features and quality"""</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    data <span class="op">=</span> []</span>
<span id="cb6-4"><a href="#cb6-4"></a>    </span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="bu">print</span>(<span class="ss">f"Training model on </span><span class="sc">{</span><span class="bu">len</span>(image_files)<span class="sc">}</span><span class="ss"> images..."</span>)</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="cf">for</span> i, img_path <span class="kw">in</span> <span class="bu">enumerate</span>(image_files):</span>
<span id="cb6-7"><a href="#cb6-7"></a>        <span class="cf">if</span> i <span class="op">%</span> <span class="dv">10</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb6-8"><a href="#cb6-8"></a>            <span class="bu">print</span>(<span class="ss">f"Processing image </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span><span class="bu">len</span>(image_files)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-9"><a href="#cb6-9"></a>            </span>
<span id="cb6-10"><a href="#cb6-10"></a>        <span class="cf">try</span>:</span>
<span id="cb6-11"><a href="#cb6-11"></a>            img <span class="op">=</span> Image.<span class="bu">open</span>(img_path)</span>
<span id="cb6-12"><a href="#cb6-12"></a>            features <span class="op">=</span> extract_features(img)</span>
<span id="cb6-13"><a href="#cb6-13"></a>            </span>
<span id="cb6-14"><a href="#cb6-14"></a>            <span class="co"># Compress at different quality levels</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>            <span class="cf">for</span> quality <span class="kw">in</span> quality_range:</span>
<span id="cb6-16"><a href="#cb6-16"></a>                compressed <span class="op">=</span> encode_jpeg(img, quality)</span>
<span id="cb6-17"><a href="#cb6-17"></a>                size <span class="op">=</span> <span class="bu">len</span>(compressed)</span>
<span id="cb6-18"><a href="#cb6-18"></a>                </span>
<span id="cb6-19"><a href="#cb6-19"></a>                <span class="co"># Store features, quality, and resulting size</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>                sample <span class="op">=</span> features.copy()</span>
<span id="cb6-21"><a href="#cb6-21"></a>                sample[<span class="st">'quality'</span>] <span class="op">=</span> quality</span>
<span id="cb6-22"><a href="#cb6-22"></a>                sample[<span class="st">'compressed_size'</span>] <span class="op">=</span> size</span>
<span id="cb6-23"><a href="#cb6-23"></a>                sample[<span class="st">'compression_ratio'</span>] <span class="op">=</span> size <span class="op">/</span> features[<span class="st">'size_raw'</span>]</span>
<span id="cb6-24"><a href="#cb6-24"></a>                data.append(sample)</span>
<span id="cb6-25"><a href="#cb6-25"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb6-26"><a href="#cb6-26"></a>            <span class="bu">print</span>(<span class="ss">f"Error processing </span><span class="sc">{</span>img_path<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-27"><a href="#cb6-27"></a>    </span>
<span id="cb6-28"><a href="#cb6-28"></a>    <span class="co"># Convert to DataFrame</span></span>
<span id="cb6-29"><a href="#cb6-29"></a>    df <span class="op">=</span> pd.DataFrame(data)</span>
<span id="cb6-30"><a href="#cb6-30"></a>    </span>
<span id="cb6-31"><a href="#cb6-31"></a>    <span class="co"># Train model to predict compression ratio from features + quality</span></span>
<span id="cb6-32"><a href="#cb6-32"></a>    X <span class="op">=</span> df.drop([<span class="st">'compressed_size'</span>, <span class="st">'compression_ratio'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-33"><a href="#cb6-33"></a>    y <span class="op">=</span> df[<span class="st">'compression_ratio'</span>]  <span class="co"># Predict ratio rather than absolute size</span></span>
<span id="cb6-34"><a href="#cb6-34"></a>    </span>
<span id="cb6-35"><a href="#cb6-35"></a>    model <span class="op">=</span> GradientBoostingRegressor(</span>
<span id="cb6-36"><a href="#cb6-36"></a>        n_estimators<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb6-37"><a href="#cb6-37"></a>        max_depth<span class="op">=</span><span class="dv">5</span>,</span>
<span id="cb6-38"><a href="#cb6-38"></a>        learning_rate<span class="op">=</span><span class="fl">0.1</span></span>
<span id="cb6-39"><a href="#cb6-39"></a>    )</span>
<span id="cb6-40"><a href="#cb6-40"></a>    model.fit(X, y)</span>
<span id="cb6-41"><a href="#cb6-41"></a>    </span>
<span id="cb6-42"><a href="#cb6-42"></a>    <span class="co"># Print feature importance</span></span>
<span id="cb6-43"><a href="#cb6-43"></a>    importance <span class="op">=</span> pd.DataFrame({</span>
<span id="cb6-44"><a href="#cb6-44"></a>        <span class="st">'Feature'</span>: X.columns,</span>
<span id="cb6-45"><a href="#cb6-45"></a>        <span class="st">'Importance'</span>: model.feature_importances_</span>
<span id="cb6-46"><a href="#cb6-46"></a>    }).sort_values(<span class="st">'Importance'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb6-47"><a href="#cb6-47"></a>    </span>
<span id="cb6-48"><a href="#cb6-48"></a>    <span class="bu">print</span>(<span class="st">"Top 5 features for prediction:"</span>)</span>
<span id="cb6-49"><a href="#cb6-49"></a>    <span class="bu">print</span>(importance.head(<span class="dv">5</span>))</span>
<span id="cb6-50"><a href="#cb6-50"></a>    </span>
<span id="cb6-51"><a href="#cb6-51"></a>    <span class="cf">return</span> model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now the critical function - predicting quality for a target size:</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">def</span> predict_quality_for_size(model, image, target_bytes):</span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="co">"""Predict quality setting needed to achieve target file size"""</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    features <span class="op">=</span> extract_features(image)</span>
<span id="cb7-4"><a href="#cb7-4"></a>    raw_size <span class="op">=</span> features[<span class="st">'size_raw'</span>]</span>
<span id="cb7-5"><a href="#cb7-5"></a>    target_ratio <span class="op">=</span> target_bytes <span class="op">/</span> raw_size</span>
<span id="cb7-6"><a href="#cb7-6"></a>    </span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="co"># Since we're predicting compression ratio, we need to find</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>    <span class="co"># which quality gives the closest ratio to our target</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>    best_quality <span class="op">=</span> <span class="va">None</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>    min_diff <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb7-11"><a href="#cb7-11"></a>    </span>
<span id="cb7-12"><a href="#cb7-12"></a>    <span class="cf">for</span> quality <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>, <span class="dv">96</span>):</span>
<span id="cb7-13"><a href="#cb7-13"></a>        test_features <span class="op">=</span> features.copy()</span>
<span id="cb7-14"><a href="#cb7-14"></a>        test_features[<span class="st">'quality'</span>] <span class="op">=</span> quality</span>
<span id="cb7-15"><a href="#cb7-15"></a>        <span class="co"># Convert to DataFrame format</span></span>
<span id="cb7-16"><a href="#cb7-16"></a>        test_df <span class="op">=</span> pd.DataFrame([test_features])</span>
<span id="cb7-17"><a href="#cb7-17"></a>        </span>
<span id="cb7-18"><a href="#cb7-18"></a>        <span class="co"># Predict compression ratio for this quality</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>        predicted_ratio <span class="op">=</span> model.predict(test_df)[<span class="dv">0</span>]</span>
<span id="cb7-20"><a href="#cb7-20"></a>        predicted_size <span class="op">=</span> predicted_ratio <span class="op">*</span> raw_size</span>
<span id="cb7-21"><a href="#cb7-21"></a>        </span>
<span id="cb7-22"><a href="#cb7-22"></a>        diff <span class="op">=</span> <span class="bu">abs</span>(predicted_size <span class="op">-</span> target_bytes)</span>
<span id="cb7-23"><a href="#cb7-23"></a>        <span class="cf">if</span> diff <span class="op">&lt;</span> min_diff:</span>
<span id="cb7-24"><a href="#cb7-24"></a>            min_diff <span class="op">=</span> diff</span>
<span id="cb7-25"><a href="#cb7-25"></a>            best_quality <span class="op">=</span> quality</span>
<span id="cb7-26"><a href="#cb7-26"></a>    </span>
<span id="cb7-27"><a href="#cb7-27"></a>    <span class="cf">return</span> best_quality</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Finally, let’s combine our ML prediction with binary search for fine-tuning:</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">def</span> smart_compress_to_size(model, image, target_bytes, tolerance<span class="op">=</span><span class="dv">1024</span>):</span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="co">"""Compress image to target size using ML prediction + binary search refinement"""</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="co"># Step 1: Predict quality using ML model</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>    predicted_quality <span class="op">=</span> predict_quality_for_size(model, image, target_bytes)</span>
<span id="cb8-5"><a href="#cb8-5"></a>    </span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="co"># Step 2: Try the predicted quality</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>    compressed <span class="op">=</span> encode_jpeg(image, quality<span class="op">=</span>predicted_quality)</span>
<span id="cb8-8"><a href="#cb8-8"></a>    size <span class="op">=</span> <span class="bu">len</span>(compressed)</span>
<span id="cb8-9"><a href="#cb8-9"></a>    </span>
<span id="cb8-10"><a href="#cb8-10"></a>    <span class="bu">print</span>(<span class="ss">f"ML predicted quality: </span><span class="sc">{</span>predicted_quality<span class="sc">}</span><span class="ss"> -&gt; Size: </span><span class="sc">{</span>size<span class="op">/</span><span class="dv">1024</span><span class="sc">:.1f}</span><span class="ss">KB"</span>)</span>
<span id="cb8-11"><a href="#cb8-11"></a>    </span>
<span id="cb8-12"><a href="#cb8-12"></a>    <span class="co"># Step 3: If we're close enough, we're done</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="cf">if</span> <span class="bu">abs</span>(size <span class="op">-</span> target_bytes) <span class="op">&lt;=</span> tolerance:</span>
<span id="cb8-14"><a href="#cb8-14"></a>        <span class="cf">return</span> compressed</span>
<span id="cb8-15"><a href="#cb8-15"></a>    </span>
<span id="cb8-16"><a href="#cb8-16"></a>    <span class="co"># Step 4: Not close enough, refine with narrow binary search</span></span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span class="bu">print</span>(<span class="st">"Fine-tuning with binary search..."</span>)</span>
<span id="cb8-18"><a href="#cb8-18"></a>    search_range <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb8-19"><a href="#cb8-19"></a>    <span class="cf">if</span> size <span class="op">&gt;</span> target_bytes:</span>
<span id="cb8-20"><a href="#cb8-20"></a>        <span class="co"># Too big, search lower qualities</span></span>
<span id="cb8-21"><a href="#cb8-21"></a>        q_min, q_max <span class="op">=</span> <span class="bu">max</span>(<span class="dv">5</span>, predicted_quality <span class="op">-</span> search_range), predicted_quality <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb8-22"><a href="#cb8-22"></a>    <span class="cf">else</span>:</span>
<span id="cb8-23"><a href="#cb8-23"></a>        <span class="co"># Too small, search higher qualities</span></span>
<span id="cb8-24"><a href="#cb8-24"></a>        q_min, q_max <span class="op">=</span> predicted_quality <span class="op">+</span> <span class="dv">1</span>, <span class="bu">min</span>(<span class="dv">95</span>, predicted_quality <span class="op">+</span> search_range)</span>
<span id="cb8-25"><a href="#cb8-25"></a>    </span>
<span id="cb8-26"><a href="#cb8-26"></a>    <span class="co"># Use regular binary search in narrower range</span></span>
<span id="cb8-27"><a href="#cb8-27"></a>    <span class="cf">return</span> compress_to_target_size(</span>
<span id="cb8-28"><a href="#cb8-28"></a>        image, </span>
<span id="cb8-29"><a href="#cb8-29"></a>        target_bytes,</span>
<span id="cb8-30"><a href="#cb8-30"></a>        q_min<span class="op">=</span>q_min,</span>
<span id="cb8-31"><a href="#cb8-31"></a>        q_max<span class="op">=</span>q_max</span>
<span id="cb8-32"><a href="#cb8-32"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="experiments-and-results" class="level2">
<h2 class="anchored" data-anchor-id="experiments-and-results">Experiments and results</h2>
<p>Now let’s evaluate our approach with different image types. I collected a dataset of 1,000 diverse images and trained our model using a 80/20 train/test split.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># Load image dataset - check multiple extensions</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>image_files <span class="op">=</span> []</span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="cf">for</span> ext <span class="kw">in</span> [<span class="st">'.jpeg'</span>, <span class="st">'.jpg'</span>, <span class="st">'.png'</span>]:</span>
<span id="cb9-4"><a href="#cb9-4"></a>    files <span class="op">=</span> glob.glob(<span class="ss">f"photos/*</span><span class="sc">{</span>ext<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="cf">if</span> files:</span>
<span id="cb9-6"><a href="#cb9-6"></a>        <span class="bu">print</span>(<span class="ss">f"Found </span><span class="sc">{</span><span class="bu">len</span>(files)<span class="sc">}</span><span class="ss"> files with extension </span><span class="sc">{</span>ext<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-7"><a href="#cb9-7"></a>        image_files.extend(files)</span>
<span id="cb9-8"><a href="#cb9-8"></a>        </span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="cf">if</span> <span class="kw">not</span> image_files:</span>
<span id="cb9-10"><a href="#cb9-10"></a>    <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"No image files found in the photos directory"</span>)</span>
<span id="cb9-11"><a href="#cb9-11"></a>    </span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="bu">print</span>(<span class="ss">f"Found </span><span class="sc">{</span><span class="bu">len</span>(image_files)<span class="sc">}</span><span class="ss"> total images"</span>)</span>
<span id="cb9-13"><a href="#cb9-13"></a></span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="co"># Split into training and testing sets</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>train_files, test_files <span class="op">=</span> train_test_split(image_files, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb9-16"><a href="#cb9-16"></a></span>
<span id="cb9-17"><a href="#cb9-17"></a><span class="co"># Train the prediction model</span></span>
<span id="cb9-18"><a href="#cb9-18"></a>model <span class="op">=</span> train_size_predictor(train_files)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Found 73 files with extension .jpeg
Found 73 total images
Training model on 58 images...
Processing image 0/58
Processing image 10/58
Processing image 20/58
Processing image 30/58
Processing image 40/58
Processing image 50/58
Top 5 features for prediction:
        Feature  Importance
9       quality    0.757299
5       entropy    0.096391
4  edge_density    0.055317
6      variance    0.050526
1        height    0.015152</code></pre>
</div>
</div>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">def</span> evaluate_compression_methods(test_files, model, target_kb<span class="op">=</span><span class="dv">200</span>):</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="co">"""Compare binary search and ML-assisted compression with simple metrics"""</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    results <span class="op">=</span> []</span>
<span id="cb11-4"><a href="#cb11-4"></a>    </span>
<span id="cb11-5"><a href="#cb11-5"></a>    <span class="cf">for</span> i, img_path <span class="kw">in</span> <span class="bu">enumerate</span>(test_files[:<span class="dv">3</span>]):  <span class="co"># Just test 3 images</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>        img <span class="op">=</span> Image.<span class="bu">open</span>(img_path)</span>
<span id="cb11-7"><a href="#cb11-7"></a>        target_bytes <span class="op">=</span> target_kb <span class="op">*</span> <span class="dv">1024</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>        </span>
<span id="cb11-9"><a href="#cb11-9"></a>        <span class="co"># Binary search method</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>        bs_start <span class="op">=</span> time.time()</span>
<span id="cb11-11"><a href="#cb11-11"></a>        bs_iterations <span class="op">=</span> [<span class="dv">0</span>]  <span class="co"># Use a list to track iterations inside function</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>        </span>
<span id="cb11-13"><a href="#cb11-13"></a>        <span class="kw">def</span> count_bs_iteration(<span class="op">*</span>args):</span>
<span id="cb11-14"><a href="#cb11-14"></a>            bs_iterations[<span class="dv">0</span>] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb11-15"><a href="#cb11-15"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>            </span>
<span id="cb11-17"><a href="#cb11-17"></a>        <span class="cf">with</span> patch(<span class="st">'builtins.print'</span>, side_effect<span class="op">=</span>count_bs_iteration):  <span class="co"># Suppress output</span></span>
<span id="cb11-18"><a href="#cb11-18"></a>            bs_result <span class="op">=</span> compress_to_target_size(img, target_bytes)</span>
<span id="cb11-19"><a href="#cb11-19"></a>        </span>
<span id="cb11-20"><a href="#cb11-20"></a>        bs_time <span class="op">=</span> time.time() <span class="op">-</span> bs_start</span>
<span id="cb11-21"><a href="#cb11-21"></a>        bs_error <span class="op">=</span> <span class="bu">abs</span>(<span class="bu">len</span>(bs_result) <span class="op">-</span> target_bytes) <span class="op">/</span> target_bytes <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb11-22"><a href="#cb11-22"></a>        </span>
<span id="cb11-23"><a href="#cb11-23"></a>        <span class="co"># ML method</span></span>
<span id="cb11-24"><a href="#cb11-24"></a>        ml_start <span class="op">=</span> time.time()</span>
<span id="cb11-25"><a href="#cb11-25"></a>        ml_iterations <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb11-26"><a href="#cb11-26"></a>        </span>
<span id="cb11-27"><a href="#cb11-27"></a>        <span class="kw">def</span> count_ml_iteration(<span class="op">*</span>args):  <span class="co"># NEW: Separate counter function for ML</span></span>
<span id="cb11-28"><a href="#cb11-28"></a>            ml_iterations[<span class="dv">0</span>] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb11-29"><a href="#cb11-29"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb11-30"><a href="#cb11-30"></a>            </span>
<span id="cb11-31"><a href="#cb11-31"></a>        <span class="cf">with</span> patch(<span class="st">'builtins.print'</span>, side_effect<span class="op">=</span>count_ml_iteration):  <span class="co"># Use ML-specific counter</span></span>
<span id="cb11-32"><a href="#cb11-32"></a>            ml_result <span class="op">=</span> smart_compress_to_size(model, img, target_bytes)</span>
<span id="cb11-33"><a href="#cb11-33"></a>            </span>
<span id="cb11-34"><a href="#cb11-34"></a>        ml_time <span class="op">=</span> time.time() <span class="op">-</span> ml_start</span>
<span id="cb11-35"><a href="#cb11-35"></a>        ml_error <span class="op">=</span> <span class="bu">abs</span>(<span class="bu">len</span>(ml_result) <span class="op">-</span> target_bytes) <span class="op">/</span> target_bytes <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb11-36"><a href="#cb11-36"></a>        </span>
<span id="cb11-37"><a href="#cb11-37"></a>        <span class="co"># Save results</span></span>
<span id="cb11-38"><a href="#cb11-38"></a>        results.append({</span>
<span id="cb11-39"><a href="#cb11-39"></a>            <span class="st">'image'</span>: os.path.basename(img_path),</span>
<span id="cb11-40"><a href="#cb11-40"></a>            <span class="st">'bs_iterations'</span>: bs_iterations[<span class="dv">0</span>],</span>
<span id="cb11-41"><a href="#cb11-41"></a>            <span class="st">'ml_iterations'</span>: ml_iterations[<span class="dv">0</span>],</span>
<span id="cb11-42"><a href="#cb11-42"></a>            <span class="st">'bs_time'</span>: bs_time,</span>
<span id="cb11-43"><a href="#cb11-43"></a>            <span class="st">'ml_time'</span>: ml_time,</span>
<span id="cb11-44"><a href="#cb11-44"></a>            <span class="st">'bs_error'</span>: bs_error,</span>
<span id="cb11-45"><a href="#cb11-45"></a>            <span class="st">'ml_error'</span>: ml_error,</span>
<span id="cb11-46"><a href="#cb11-46"></a>            <span class="st">'speedup'</span>: bs_time <span class="op">/</span> ml_time</span>
<span id="cb11-47"><a href="#cb11-47"></a>        })</span>
<span id="cb11-48"><a href="#cb11-48"></a>    </span>
<span id="cb11-49"><a href="#cb11-49"></a>    <span class="co"># Print results in a clean table</span></span>
<span id="cb11-50"><a href="#cb11-50"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'Image'</span><span class="sc">:&lt;20}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'BS Iter'</span><span class="sc">:^8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'ML Iter'</span><span class="sc">:^8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'BS Time'</span><span class="sc">:^8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'ML Time'</span><span class="sc">:^8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'BS Err%'</span><span class="sc">:^8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'ML Err%'</span><span class="sc">:^8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Speedup'</span><span class="sc">:^8}</span><span class="ss">"</span>)</span>
<span id="cb11-51"><a href="#cb11-51"></a>    <span class="bu">print</span>(<span class="st">"-"</span> <span class="op">*</span> <span class="dv">80</span>)</span>
<span id="cb11-52"><a href="#cb11-52"></a>    </span>
<span id="cb11-53"><a href="#cb11-53"></a>    avg_speedup <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-54"><a href="#cb11-54"></a>    <span class="cf">for</span> result <span class="kw">in</span> results:</span>
<span id="cb11-55"><a href="#cb11-55"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>result[<span class="st">'image'</span>]<span class="sc">:&lt;20}</span><span class="ss"> </span><span class="sc">{</span>result[<span class="st">'bs_iterations'</span>]<span class="sc">:^8}</span><span class="ss"> </span><span class="sc">{</span>result[<span class="st">'ml_iterations'</span>]<span class="sc">:^8}</span><span class="ss"> "</span></span>
<span id="cb11-56"><a href="#cb11-56"></a>              <span class="ss">f"</span><span class="sc">{</span>result[<span class="st">'bs_time'</span>]<span class="sc">:.2f}</span><span class="ss">s </span><span class="sc">{</span>result[<span class="st">'ml_time'</span>]<span class="sc">:.2f}</span><span class="ss">s </span><span class="sc">{</span>result[<span class="st">'bs_error'</span>]<span class="sc">:.2f}</span><span class="ss">% "</span></span>
<span id="cb11-57"><a href="#cb11-57"></a>              <span class="ss">f"</span><span class="sc">{</span>result[<span class="st">'ml_error'</span>]<span class="sc">:.2f}</span><span class="ss">% </span><span class="sc">{</span>result[<span class="st">'speedup'</span>]<span class="sc">:.2f}</span><span class="ss">x"</span>)</span>
<span id="cb11-58"><a href="#cb11-58"></a>        avg_speedup <span class="op">+=</span> result[<span class="st">'speedup'</span>]</span>
<span id="cb11-59"><a href="#cb11-59"></a>    </span>
<span id="cb11-60"><a href="#cb11-60"></a>    <span class="bu">print</span>(<span class="st">"-"</span> <span class="op">*</span> <span class="dv">80</span>)</span>
<span id="cb11-61"><a href="#cb11-61"></a>    <span class="bu">print</span>(<span class="ss">f"Average speedup: </span><span class="sc">{</span>avg_speedup<span class="op">/</span><span class="bu">len</span>(results)<span class="sc">:.2f}</span><span class="ss">x"</span>)</span>
<span id="cb11-62"><a href="#cb11-62"></a>    </span>
<span id="cb11-63"><a href="#cb11-63"></a>    <span class="cf">return</span> results</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>results <span class="op">=</span> evaluate_compression_methods(test_files, model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Image                BS Iter  ML Iter  BS Time  ML Time  BS Err%  ML Err%  Speedup 
--------------------------------------------------------------------------------
IMG_1281.jpeg           8        6     1.10s 1.80s 0.59% 71.11% 0.61x
IMG_1217.jpeg           7        3     2.12s 2.96s 106.04% 106.04% 0.72x
IMG_1946.jpeg           7        3     1.27s 1.40s 95.53% 95.53% 0.90x
--------------------------------------------------------------------------------
Average speedup: 0.74x</code></pre>
</div>
</div>
<p>Let’s break down what these numbers tell us:</p>
<section id="iteration-efficiency" class="level3">
<h3 class="anchored" data-anchor-id="iteration-efficiency">Iteration Efficiency</h3>
<p>Our machine learning model successfully reduced the number of compression attempts needed compared to binary search (average of ~4 iterations vs ~7). This validates our hypothesis that ML can help guide the search process more efficiently. The model is correctly “learning” something about the relationship between image features and compression parameters.</p>
</section>
<section id="time-performance" class="level3">
<h3 class="anchored" data-anchor-id="time-performance">Time Performance</h3>
<p>Contrary to my initial expectations, despite requiring fewer iterations, the ML-assisted approach is actually slower overall, with an average speedup of 0.74x (meaning it’s roughly 26% slower than binary search). This is revealing: the computational overhead of extracting image features and running the prediction model outweighs the time saved from fewer compression attempts. This makes sense in retrospect - our feature extraction involves several computationally intensive operations (edge detection, entropy calculation, etc.), and the gradient boosting model prediction isn’t free either. For simple binary search where each step is just a JPEG compression attempt, there’s very little overhead beyond the compression itself.</p>
</section>
<section id="accuracy-comparison" class="level3">
<h3 class="anchored" data-anchor-id="accuracy-comparison">Accuracy Comparison</h3>
<p>The accuracy results show an interesting pattern:</p>
<p>For two images (IMG_1217 and IMG_1946), both methods achieved identical error rates (albeit high ones at 106% and 95%) For one image (IMG_1281), the binary search method was dramatically more accurate (0.59% error vs 71.11%)</p>
<p>This suggests that our ML model struggles with certain types of images, failing to generalize well across the entire dataset. This isn’t entirely surprising - compression efficiency is highly content-dependent, and our feature set, while carefully chosen, may not capture all the nuances that affect JPEG compression.</p>
</section>
</section>
<section id="why-machine-learning-falls-short" class="level2">
<h2 class="anchored" data-anchor-id="why-machine-learning-falls-short">Why Machine Learning Falls Short</h2>
<p>Our findings highlight some fundamental challenges in applying ML to this compression problem:</p>
<p>Feature Extraction Overhead: The time spent calculating edge density, entropy, and other features is substantial. While these calculations happen just once per image, they’re expensive enough to negate the benefit of fewer compression attempts.</p>
<p>Model Generalization: The high error rate for some images indicates our model doesn’t generalize perfectly across different image types. This is a common challenge in ML - the relationship between image features and optimal compression settings is complex and may require more sophisticated features or model architectures.</p>
<p>Discrete Output Space: JPEG quality is an integer parameter, which means our regression model is trying to predict a discrete value. This can lead to step-function behavior where small differences in prediction lead to large differences in results.</p>
<p>Non-linear Relationship: The relationship between quality settings and file size is highly non-linear and varies significantly by image content, making it difficult to model accurately.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>While our ML approach didn’t deliver the performance improvements I initially hoped for, it revealed important lessons about the trade-offs involved.</p>
<p>The results remind me that sometimes simple algorithms like binary search are hard to beat, especially when the overhead of a more complex approach outweighs its benefits. This doesn’t mean ML has no place in compression - rather, it suggests we need to be thoughtful about where and how we apply it.</p>
<p>For everyday compression needs, the traditional binary search approach remains efficient and reliable. However, I believe there’s still potential for ML to enhance compression in specialized scenarios, particularly where patterns in the data can be leveraged or where quality optimization is as important as reaching a target file size.</p>
<p>Future work in this area might explore more sophisticated feature engineering, domain-specific models, or hybrid approaches that combine the strengths of traditional algorithms with the predictive power of machine learning. As for that annoying “file must be under 2MB” requirement that inspired this project? For now, I’ll stick with binary search to meet those constraints, but I’m excited about the possibilities that continued research in this area might bring.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">© 2023 Anweshan Adhikari</div>   
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com">
      <i class="bi bi-twitter" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>



</body></html>